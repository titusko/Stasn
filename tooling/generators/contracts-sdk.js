
const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// This script generates TypeScript SDK from compiled contracts
async function generateContractsSDK() {
  console.log('Generating Contract SDK...');
  
  // Ensure blockchain package is built
  try {
    execSync('pnpm --filter blockchain build', { stdio: 'inherit' });
  } catch (error) {
    console.error('Failed to build blockchain package:', error);
    process.exit(1);
  }
  
  const artifactsDir = path.join(__dirname, '../../packages/blockchain/artifacts/contracts');
  const sdkDir = path.join(__dirname, '../../packages/contracts-sdk/src');
  
  // Create SDK directory if it doesn't exist
  fs.mkdirSync(sdkDir, { recursive: true });
  
  // Generate index file
  let indexContent = `// Auto-generated by contracts-sdk.js\n// DO NOT EDIT DIRECTLY\n\n`;
  
  // Check if artifacts directory exists
  if (!fs.existsSync(artifactsDir)) {
    console.error(`Artifacts directory not found: ${artifactsDir}`);
    console.log('Make sure to compile contracts first with: pnpm --filter blockchain compile');
    process.exit(1);
  }
  
  // Read all contract artifacts
  const contracts = fs.readdirSync(artifactsDir)
    .filter(file => file.endsWith('.sol'))
    .map(folder => {
      const contractName = path.basename(folder, '.sol');
      const files = fs.readdirSync(path.join(artifactsDir, folder));
      const jsonFile = files.find(file => file.endsWith('.json') && !file.includes('.dbg.'));
      
      if (!jsonFile) {
        console.warn(`No JSON artifact found for ${contractName}`);
        return null;
      }
      
      const artifact = JSON.parse(fs.readFileSync(path.join(artifactsDir, folder, jsonFile), 'utf8'));
      
      // Generate TypeScript file for contract
      const contractContent = `// Auto-generated by contracts-sdk.js
// DO NOT EDIT DIRECTLY

import { ethers } from 'ethers';

export const ${contractName}Address = '${process.env.CONTRACT_ADDRESS || '0x0000000000000000000000000000000000000000'}';

export const ${contractName}ABI = ${JSON.stringify(artifact.abi, null, 2)} as const;

export type ${contractName}Interface = ethers.BaseContract & {
${artifact.abi.filter(item => item.type === 'function').map(func => {
  const inputs = func.inputs.map(input => `${input.name || `arg${index}`}: ${getTypeScriptType(input.type)}`).join(', ');
  const outputs = func.outputs.length === 1 
    ? getTypeScriptType(func.outputs[0].type)
    : `[${func.outputs.map(output => getTypeScriptType(output.type)).join(', ')}]`;
  
  return `  ${func.name}(${inputs}): Promise<${outputs}>;`;
}).join('\n')}
};

export function get${contractName}Contract(
  provider: ethers.Provider | ethers.Signer
): ${contractName}Interface {
  return new ethers.Contract(
    ${contractName}Address,
    ${contractName}ABI,
    provider
  ) as unknown as ${contractName}Interface;
}
`;
      
      fs.writeFileSync(path.join(sdkDir, `${contractName}.ts`), contractContent);
      indexContent += `export * from './${contractName}';\n`;
      
      return contractName;
    })
    .filter(Boolean);
  
  // Write index file
  fs.writeFileSync(path.join(sdkDir, 'index.ts'), indexContent);
  
  // Update package.json version
  const packageJsonPath = path.join(__dirname, '../../packages/contracts-sdk/package.json');
  
  if (fs.existsSync(packageJsonPath)) {
    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
    
    // Increment patch version
    const versionParts = packageJson.version.split('.');
    versionParts[2] = (parseInt(versionParts[2]) + 1).toString();
    packageJson.version = versionParts.join('.');
    
    fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));
    console.log(`✅ Updated contracts-sdk to version ${packageJson.version}`);
  } else {
    // Create package.json if it doesn't exist
    const packageJson = {
      "name": "contracts-sdk",
      "version": "0.0.1",
      "private": true,
      "main": "./dist/index.js",
      "types": "./dist/index.d.ts",
      "scripts": {
        "build": "tsc",
        "clean": "rm -rf dist",
        "dev": "tsc --watch"
      },
      "dependencies": {
        "ethers": "^6.8.1"
      },
      "devDependencies": {
        "typescript": "^5.2.2",
        "tsconfig": "workspace:*"
      }
    };
    
    fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));
    console.log(`✅ Created contracts-sdk package.json`);
  }
  
  // Create tsconfig.json if it doesn't exist
  const tsconfigPath = path.join(__dirname, '../../packages/contracts-sdk/tsconfig.json');
  if (!fs.existsSync(tsconfigPath)) {
    const tsconfig = {
      "extends": "tsconfig/base.json",
      "compilerOptions": {
        "outDir": "./dist",
        "rootDir": "./src"
      },
      "include": ["src"]
    };
    
    fs.writeFileSync(tsconfigPath, JSON.stringify(tsconfig, null, 2));
  }
  
  console.log(`✅ Generated SDK for ${contracts.length} contracts`);
}

function getTypeScriptType(solidityType) {
  if (solidityType.includes('uint') || solidityType.includes('int')) return 'bigint';
  if (solidityType === 'bool') return 'boolean';
  if (solidityType === 'address') return 'string';
  if (solidityType.includes('bytes')) return 'string';
  if (solidityType === 'string') return 'string';
  if (solidityType.includes('[]')) return `${getTypeScriptType(solidityType.replace('[]', ''))}[]`;
  return 'any';
}

generateContractsSDK().catch(console.error);
