const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// This script generates TypeScript SDK from compiled contracts
async function generateContractsSDK() {
  console.log('Generating Contract SDK...');

  // Ensure blockchain package is built
  execSync('pnpm --filter blockchain build', { stdio: 'inherit' });

  const artifactsDir = path.join(__dirname, '../../packages/blockchain/artifacts/contracts');
  const sdkDir = path.join(__dirname, '../../packages/contracts-sdk/src');

  // Create SDK directory if it doesn't exist
  fs.mkdirSync(sdkDir, { recursive: true });

  // Generate index file
  let indexContent = `// Auto-generated by contracts-sdk.js\n// DO NOT EDIT DIRECTLY\n\n`;

  // Read all contract artifacts
  const contracts = fs.readdirSync(artifactsDir)
    .filter(file => file.endsWith('.json'))
    .map(file => {
      const contractName = path.basename(file, '.json');
      const artifact = JSON.parse(fs.readFileSync(path.join(artifactsDir, file), 'utf8'));

      // Generate TypeScript file for contract
      const contractContent = `// Auto-generated by contracts-sdk.js
// DO NOT EDIT DIRECTLY

import { ethers } from 'ethers';

export const ${contractName}Address = '${process.env.CONTRACT_ADDRESS || '0x0000000000000000000000000000000000000000'}';

export const ${contractName}ABI = ${JSON.stringify(artifact.abi, null, 2)} as const;

export type ${contractName}Interface = ethers.BaseContract & {
${artifact.abi.filter(item => item.type === 'function').map(func => {
  const inputs = func.inputs.map(input => `${input.name}: ${getTypeScriptType(input.type)}`).join(', ');
  const outputs = func.outputs.length === 1 
    ? getTypeScriptType(func.outputs[0].type)
    : `[${func.outputs.map(output => getTypeScriptType(output.type)).join(', ')}]`;

  return `  ${func.name}(${inputs}): Promise<${outputs}>;`;
}).join('\n')}
};

export function get${contractName}Contract(
  provider: ethers.Provider | ethers.Signer
): ${contractName}Interface {
  return new ethers.Contract(
    ${contractName}Address,
    ${contractName}ABI,
    provider
  ) as unknown as ${contractName}Interface;
}
`;

      fs.writeFileSync(path.join(sdkDir, `${contractName}.ts`), contractContent);
      indexContent += `export * from './${contractName}';\n`;

      return contractName;
    });

  // Write index file
  fs.writeFileSync(path.join(sdkDir, 'index.ts'), indexContent);

  // Update package.json version
  const packageJsonPath = path.join(__dirname, '../../packages/contracts-sdk/package.json');
  const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));

  // Increment patch version
  const versionParts = packageJson.version.split('.');
  versionParts[2] = (parseInt(versionParts[2]) + 1).toString();
  packageJson.version = versionParts.join('.');

  fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));

  console.log(`✅ Generated SDK for ${contracts.length} contracts`);
  console.log(`✅ Updated contracts-sdk to version ${packageJson.version}`);
}

function getTypeScriptType(solidityType) {
  if (solidityType.includes('uint') || solidityType.includes('int')) return 'bigint';
  if (solidityType === 'bool') return 'boolean';
  if (solidityType === 'address') return 'string';
  if (solidityType.includes('bytes')) return 'string';
  if (solidityType === 'string') return 'string';
  if (solidityType.includes('[]')) return `${getTypeScriptType(solidityType.replace('[]', ''))}[]`;
  return 'any';
}

generateContractsSDK().catch(console.error);